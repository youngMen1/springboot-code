幂等问题 8种方案解决重复提交
1.什么是幂等
![img](/doc/微信截图_20191121193423.png)
`在我们编程中常见幂等
 1)select查询天然幂等  
 2)delete删除也是幂等,删除同一个多次效果一样 
 3)update直接更新某个值的,幂等 
 4)update更新累加操作的,非幂等 
 5)insert非幂等操作,每次新增一条`
 
2.产生原因
 `由于重复点击或者网络重发  eg:  
  1)点击提交按钮两次;
  2)点击刷新按钮;
  3)使用浏览器后退按钮重复之前的操作，导致重复提交表单;
  4)使用浏览器历史记录重复提交表单;
  5)浏览器重复的HTTP请;
  6)nginx重发等情况;
  7)分布式RPC的try重发等;
`
3.解决方案
1)前端js提交禁止按钮可以用一些js组件
2)使用Post/Redirect/Get模式
`在提交后执行页面重定向，这就是所谓的
 Post-Redirect-Get (PRG)模式。简言之，
 当用户提交了表单后，你去执行一个客户端的重定向，
 转到提交成功信息页面。这能避免用户按F5导致的
 重复提交，而其也不会出现浏览器表单重复提交的警告，
 也能消除按浏览器前进和后退按导致的同样问题。`
3)在session中存放一个特殊标志
`在服务器端，生成一个唯一的标识符，将它存入session，
 同时将它写入表单的隐藏字段中，然后将表单页面发给浏览器，
 用户录入信息后点击提交，在服务器端，获取表单中隐藏字段
 的值，与session中的唯一标识符比较，相等说明是首次提交，
 就处理本次请求，然后将session中的唯一标识符移除；不相等
 说明是重复提交，就不再处理。`
5)借助数据库
`insert使用唯一索引 update使用 乐观锁 version版本法
 这种在大数据量和高并发下效率依赖数据库硬件能力,可针对非核心业务
 `
6)借助悲观锁
`使用select ... for update  ,这种和 synchronized 
 锁住先查再insert or update一样,但要避免死锁,效率也较差 
 针对单体 请求并发不大 
 `
7)借助本地锁本文重点
`原理:使用了 ConcurrentHashMap 并发容器 putIfAbsent 方法,
 和 ScheduledThreadPoolExecutor 定时任务,也可以使用guava cache
 的机制, gauva中有配有缓存的有效时间 也是可以的key的生成 
 Content-MD5 Content-MD5 是指 Body 的 MD5 值，
 只有当 Body 非Form表单时才计算MD5，计算方式直接将参数和参数名称统一加密MD5
 MD5在一定范围类认为是唯一的 近似唯一  当然在低并发的情况下足够了 
 当然本地锁只适用于单机部署的应用.
 `
## 本地锁解决方案



## redis方案
### 重复提交（分布式）
单机版中我们用的是Guava Cache，但是这玩意存在集群的时候就凉了，所以我们还是要借助类似Redis、ZooKeeper 之类的中间件实现分布式锁。
### 本章目标
利用 自定义注解、Spring Aop、Redis Cache 实现分布式锁，你想锁表单锁表单，想锁接口锁接口….
### 导入依赖
在 pom.xml 中添加上 starter-web、starter-aop、starter-data-redis 的依赖即可
### CacheLock 注解
创建一个 CacheLock 注解，本章内容都是实战使用过的，所以属性配置会相对完善了，话不多说注释都给各位写齐全了….
* prefix： 缓存中 key 的前缀
* expire： 过期时间，此处默认为 5 秒
* timeUnit： 超时单位，此处默认为秒
* delimiter： key 的分隔符，将不同参数值分割开来
### CacheParam 注解
上一篇中给说过 key 的生成规则是自己定义的，如果通过表达式语法自己得去写解析规则还是比较麻烦的，所以依旧是用注解的方式
### Key 生成策略（接口）
创建一个 CacheKeyGenerator 具体实现由使用者自己去注入
### Key 生成策略（实现）
解析过程虽然看上去优点绕，但认真阅读或者调试就会发现，主要是解析带 CacheLock 注解的属性，获取对应的属性值，生成一个全新的缓存 Key
### Lock 拦截器（AOP）
熟悉 Redis 的朋友都知道它是线程安全的，我们利用它的特性可以很轻松的实现一个分布式锁，如 opsForValue().setIfAbsent(key,value) 它的作用就是如果缓存中没有当前 Key 
则进行缓存同时返回 true 反之亦然；当缓存后给 key 在设置个过期时间，
防止因为系统崩溃而导致锁迟迟不释放形成死锁； 
那么我们是不是可以这样认为当返回 true 我们认为它获取到锁了，
在锁未释放的时候我们进行异常的抛出….
### RedisLockHelper
通过封装成 API 方式调用，灵活度更加高
### 控制层
在接口上添加 @CacheLock(prefix = "books")，然后动态的值可以加上@CacheParam；
生成后的新 key 将被缓存起来；（如：该接口 token = 1，那么最终的 key 值为 books:1，如果多个条件则依次类推）
### 主函数
这里需要注入前面定义好的 CacheKeyGenerator 接口具体实现…

## 优雅解决分布式限流
### 分布式限流
单机版中我们了解到 AtomicInteger、RateLimiter、Semaphore 这几种解决方案，
但它们也仅仅是单机的解决手段，在集群环境下就透心凉了，后面又讲述了 Nginx 的限流手段，
可它又属于网关层面的策略之一，并不能解决所有问题。例如供短信接口，
你无法保证消费方是否会做好限流控制，所以自己在应用层实现限流还是很有必要的。
### 本章目标
利用 自定义注解、Spring Aop、Redis Cache 实现分布式限流….
### Limit 注解
创建一个 Limit 注解，不多说注释都给各位写齐全了….
### Limit 拦截器（AOP）
熟悉 Redis 的朋友都知道它是线程安全的，我们利用它的特性可以实现分布式锁、分布式限流等组件，在一起来学SpringBoot | 第二十三篇：轻松搞定重复提交（分布式锁）中讲述了分布式锁的实现，限流相比它稍微复杂一点，官方虽然没有提供相应的API，但却提供了支持 Lua 脚本的功能，我们可以通过编写 Lua 脚本实现自己的API，同时他是满足原子性的….
下面核心就是调用 execute 方法传入我们的 Lua 脚本内容，然后通过返回值判断是否超出我们预期的范围，超出则给出错误提示。
### 控制层
在接口上添加 @Limit() 注解，如下代码会在 Redis 中生成过期时间为 100s 的 key = test 的记录，特意定义了一个 AtomicInteger 用作测试
## 参考
https://blog.battcn.com/2018/08/08/springboot/v2-cache-redislimter/
https://blog.battcn.com/2018/06/13/springboot/v2-cache-redislock/
